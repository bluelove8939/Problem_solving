# Bus Routes (Google Kickstart 2020 Round B)
# 
# Url: https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc8/00000000002d83bf
#
#   
# Hint
# 1. 바로 문제를 풀기 어렵다면 문제를 풀기 쉬운 형태로 변형하는 것이 좋다.
# 2. 도착 시간을 기준으로 생각하면 쉽게 그리디 알고리즘을 적용할 수 있다.
# 
#
# 풀이
# - 그리디 알고리즘은 현재 최선의 선택만을 하여 정답을 도출해내는 알고리즘이다.
# 
# - 이 문제에서 묻고자 하는 것은 가장 늦게 출발할 때의 출발 시간이다. 이때
#   출발 시간은 전적으로 도착시각에 따라 달라지므로 도착 시간을 기준으로
#   생각한다.
# 
# - 어떤 버스를 타고 무조건 도착해야 하는 시간이 D라 하자. 이때 버스가
#   B간격으로 도착한다면 최대한 늦게 타려면 버스를 B * (D // B)에 타야
#   한다. 따라서 최대한 늦게 출발하기 위한 출발 시간은 B * (D // B) 이다.
# 
# - 매 순간마다 이렇게 출발 시간을 정한다고 가정하면 최종적인 출발시간을
#   정할 수 있다. 예를 들어 그 이전에 타는 버스가 B2마다 도착한다면, 그
#   이전의 출발 시간은 B2 * ((B * (D // B)) // B2)이다. 이러한 과정을
#   반복하면 결국 최종적인 출발 시간을 도출해낼 수 있다. 
# 
# - 모든 문제를 그리디 알고리즘으로 풀 수 있는 것은 아니다. 그리디 알고리즘을
#   이용하기 위해서는 현재 선택한 최선의 답이 미래에도 최선의 답이어야 한다.
#   이 문제에서는 우리가 '현재' 도착 시간을 기준으로 구한 최선의 출발 시간이
#   '미래에도' 최선의 선택일 것이라는 것이 자명하므로 (미래에 늦게 출발한다는
#   것은 과거에도 늦게 출발했을 것이기 때문) 그리디 알고리즘을 적용할 수 있다.
# 
# - 앞서 확인했듯, 그리디 알고리즘은 많은 경우 재귀적으로 표현된다. 따라서
#   재귀함수를 이용하면 위와 같은 알고리즘을 쉽게 구현할 수 있다. 다만 경우에
#   따라서는 간단하게 반복문을 활용할 수도 있으니 참고할 것. 아래 코드에서는
#   단일 반복문을 이용하여 재귀 시퀀스를 구현했으나, 코드가 크게 더럽지 않다.
#   (보통 재귀 시퀀스의 분기가 하나이면 반복문을 활용하는게 좋다. 분기가 두 개
#   이상이거나 그 개수가 변하는 경우는 재귀 함수를 작성한다.) 


if __name__ == "__main__":
    T = int(input())

    for t in range(1, T+1):
        N, D = map(int, input().split())
        bus = list(map(int, input().split()))

        # 최종적인 출발 시간을 도출하는 재귀 시퀀스
        for B in reversed(bus):
            D = B * (D // B)

        print("Case #{}: {}".format(t, D))
        