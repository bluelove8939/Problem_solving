# 스타트와링크 (Baekjoon Online Judge ID: 14889)
# 
# Url: https://www.acmicpc.net/problem/14889
#
#   
# Hint
# 1. 모든 경우의 수를 순회하는 경우 재귀함수를 사용하면 편리하게 구하고자
#    하는 값(이 문제에서는 최소값)을 구할 수 있다.
# 2. 시간제한이 빡빡한 문제이므로 알고리즘을 최적화할 수 있는 가능한 한
#    모든 것을 하는 것이 좋다. 
# 
#
# 풀이
# - 사람 수가 최대 20명이고, 이들을 두 개의 팀으로 나누어야 하므로 이때 발생하는
#   모든 경우의 수를 모두 순회해야 한다.
# 
# - 동적계획법을 이용하여 모든 경우의 수를 순회한다. (문제 1번, 4번 참조)
# 
# - 모든 경우의 수를 순회하는 알고리즘은 대부분 비슷한 특징를 가진다.
#   
#   1) 기본적으로 재귀함수로 구현되므로 탈출 조건이 존재한다. 이때 탈출 조건을
#      만났다는 것은 하나의 경우를 계산했다는 의미이므로, 탈출 조건을 만난 시점에서
#      해당 경우 두 팀의 차이를 계산한다. 
#   2) 각 경우를 분기로 나눈다. 예를 들어 이 문제의 경우 n번째 사람을 스타트 팀과
#      링크 팀으로 넣는 두 가지 분기가 존재한다.
#   3) 최종적으로 최소값을 계산한 후 리턴한다.
#  
#   아래 정의된 min_difference() 함수를 참조할 것
# 
# - 파이썬으로 이 문제를 푸는 경우 시간이 상당히 촉박하다. 아래 코드에서
#   이 문제를 풀 때 적용할 수 있는 최적화 방안을 두 개 제시하였다.
#   둘 중에서 하나라도 적용하면 문제를 풀 수 있으나, 둘 다 적용하지 않으면
#   시간 초과가 뜨므로 참고할 것. 둘 다 연산량을 두 배 가량 줄여준다.
# 
#   1) 최적화 방안 1: 함수 내부의 이중 반복문에서 j를 0부터가 아니라 i부터로 한다
#   2) 최적화 방안 2: 0번째 사람을 미리 스타트 혹은 링크 팀으로 보낸다
#   
#   그리고 각 방안을 적용했을 때 시간 차이는 다음과 같다:
#    
#   * 최적화 방안 1만 젹용한 경우:   6984ms
#   * 최적화 방안 2만 젹용한 경우:   4992ms
#   * 방안 1, 2를 모두 적용한 경우:  3588ms 


N = 0
status = list()  # 각 사람들의 순서쌍에 의한 능력치가 저장되는 변수
team = list()    # 각 사람들이 어느 팀에 속하는지를 저장하는 변수 (함수에서 사용)


# 두 팀의 능력치에 대한 차이값 중 최소값을 계산하는 함수
# 기본적으로 재귀함수의 형태를 갖는다
# 
# cursor번째 사람을 스타트 팀에 넣었을 때와 링크 팀에 넣었을 때, 둘 중 어느 경우
# 두 팀 간의 차이가 최소가 되는 지를 계산하고, 그 차이를 리턴한다 
def min_difference(cursor, start, link):
    # 1) 탈출 조건: cursor가 N이 되었을 때
    #    cursor가 N이면 더이상 팀을 지정해줄 사람이 없게 되므로 함수를 종료 
    if cursor == N:
        # 탈출하기 전 해당 경우의 수에서 두 팀의 차이를 계산한 후 이를 리턴한다
        # 팀 배정 결과는 team변수에 저장되어있다 
        start_stat, link_stat = 0, 0

        for i in range(N):
            for j in range(i, N):  # 최적화 방안 1: j를 0부터가 아니라 i부터로 한다
                if team[i] == team[j]:
                    if team[i] == 0:
                        start_stat += status[i][j] + status[j][i]
                    else:
                        link_stat += status[i][j] + status[j][i]
    
        return abs(start_stat - link_stat)

    ret = 10000

    # 2) 각 경우를 분기로 나누는 부분

    #   분기 1: cursor번째 사람이 스타트 팀으로 배정되는 경우 
    if start < N / 2:
        team[cursor] = 0
        ret = min(ret, min_difference(cursor+1, start+1, link))
    
    #   분기 2: cursor번째 사람이 링크 팀으로 배정되는 경우
    if link < N / 2:
        team[cursor] = 1
        ret = min(ret, min_difference(cursor+1, start, link+1))

    # 3) 최종적으로 값을 계산하고 리턴하는 부분 
    return ret


if __name__ == "__main__":
    N = int(input())
    status = [list(map(int, input().split())) for _ in range(N)]
    team = [None for _ in range(N)]

    # 최적화 방안 2: 0번째 사람을 미리 스타트 팀으로 보낸다
    team[0] = 0

    # 이미 0번째 사람을 스타트 팀에 배정하였으므로, cursor와 start인수는 1이다
    print(min_difference(1, 1, 0))