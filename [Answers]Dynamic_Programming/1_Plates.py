# Plates (Google Kickstart 2020 Round A)
# 
# Url: https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7/00000000001d40bb
# 
#  
# Hint
# 1. 완전탐색을 사용하지 않고 이 문제를 풀 수 있는 방법은 없다.
# 2. 알고리즘의 정당성에 문제가 없다면 속도를 늘릴 수 있는 다른 방법을
#    찾는 것도 한 가지 방법이다. (memoization, cache memory ...)
# 3. 생각보다 출력형식에서 틀리는 경우가 많으니 코드를 참조할 것.
# 
#
# 풀이
# - 이 문제는 완전탐색을 이용해 모든 경우의 수를 계산하는 문제이다.
#
# - 모든 경우의 수를 보다 빠르게 계산하기 위해 동적계획법을 이용한다.
#
# - 이 문제에서 동적계획법을 이용하기 위해서는 하나의 문제를 여러 개의 순차적인
#   부분문제로 분리하는 작업이 필요하다. 이때 부분문제는 순차적이어야 하며,
#   일반적인 경우 재귀 시퀀스를 나타내는 점화식의 형태로 표현된다. 
#
# - 중복되는 부분문제는 동적계획법의 주요한 단점이다. 아래 코드에서 maxBeauty()
#   함수는 중복되는 부분문제를 만들어내므로 반드시 메모이제이션을 적용해야 한다.
#   메모이제이션은 부분문제의 결과 값을 별도의 메모리에 저장하고, 이후에 중복되는
#   부분문제가 발생하여 이 값을 다시 계산해야 될 때 메모리에서 값을 꺼내옴으로써
#   연산량을 줄이는 방법이다. 이때 각 부분문제의 해답이 별도의 메모리에 저장되므로
#   모든 부분문제는 독립적이어야 한다. 만약 그렇지 않다면 해당 문제는 동적계획법을
#   활용할 수 없는 문제이거나, 부분문제를 잘 못 분리한 것이다.
# 
# - 메모이제이션을 위해 할당하는 별도의 메모리를 일반적으로 캐시라 한다. 캐시의
#   인덱스는 부분문제의 인수에 해당하고, 이 메모리에는 해당 부분문제의 값이 저장된다.
#   
# - 캐시를 사용하기 이전에 값이 비어있는지 아닌지를 판별하기 위해 초기값을 채워넣어야
#   한다. 문제에서 요구하는 값이 될 수 없는 값으로 초기화 하는 것이 일반적이다.
#
# - maxBeauty() 함수는 서로 다른 두 개의 인수를 가지므로 캐시의 형태는 이차원이
#   될 것이다. 문제에서 구하고자 하는 값이 양수이므로 처음에는 0으로 초기화
#   해 놓는다. (문제의 정답은 절대 0이 될 수 없다) 
#  
# - 부분합을 구하는 과정을 보다 빠르게 하기 위해서는 입력을 전처리하는 것이 좋다.
#   부분합을 구하는 알고리즘은 무조건 선형시간이 걸리므로 이 작업을 여러 번
#   반복하는 것은 심각한 성능 저하를 가져올 수 있다. 입력을 전처리하는 과정에서
#   미리 부분합을 계산하고 이를 저장해 놓으면 보다 빠르게 부분합을 계산할 수 있다. 


N, K, P = 0, 0, 0
beautySum = list()
cache = list()


def maxBeauty(cursor, left):
    # 더이상 고를 그릇이 없거나 마지막 스택에 도달한 경우
    if left == 0 or cursor == N:
        return 0

    # 캐시에 이미 계산한 기록이 있는 경우
    if cache[cursor][left] != 0:
        return cache[cursor][left]
    
    # 캐시에 값이 없다면 직접 최대값을 계산한다
    ret = 0;
    for idx in range(min(left+1, K+1)):
        # 동적계획법을 적용할 때는 점화식을 세우는 것이 좋다 -> 그대로 구현하면 되기 때문
        ret = max(ret, beautySum[cursor][idx] + maxBeauty(cursor+1, left-idx))
    
    cache[cursor][left] = ret  # 캐시에 값을 저장하고 리턴

    return ret


if __name__ == "__main__":
    T = int(input())

    for t in range(1, T+1):
        N, K, P = map(int, input().split())
        beautySum = list()

        # 캐시 초기화
        # 정답은 0이 될 수 없으므로 0으로 초기화
        cache = [[0 for _ in range(1501)] for _ in range(51)]

        for _ in range(N):
            # 데이터셋을 입력받는 부분
            # 원래는 앞에 0이 없지만 지금은 넣어놓는다 (계산의 용이성 때문)
            beautySum.append([0] + list(map(int, input().split())))

            # 입력을 전처리하는 과정
            # 이 부분에서 부분합을 미리 계산한다
            # for문이 실행되고 나면 beautySum에는 부분합의 결과가 들어간다
            # 따라서 beautySum의 idx번째 요소는 Dr.Petel이 idx개의 그릇을 이 스택에서
            # 선택했을 때 얻을 수 있는 값에 해당한다 
            for idx in range(1, K+1):
                beautySum[-1][idx] += beautySum[-1][idx-1]

        # 데이터 출력
        print("Case #{}: {}".format(t, maxBeauty(0, P)))
        