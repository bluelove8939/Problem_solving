<h2><b><a href=https://programmers.co.kr/learn/challenges style="text-decoration:none;color:inherit">
2022 KAKAO BLIND RECRUITMENT
</a></b></h2>


### <b> 1. 신고 결과 받기 </b>

전형적인 브루트 포스 문제로 해석했고, 문제에서 제시한 상황을 그대로 구현하였다.
아이디를 참조하는 상황이 많이 발생하였으므로 속도를 위해 딕셔너리 자료형을 사용하였다.
C++이었으면 여러 데이터를 묶어 객체화 하기 위해 구조체를 정의하여 사용하였겠지만, 
파이썬에서는 리스트(동적배열)이 담을 수 있는 자료형이 고정되어있지 않으므로,
리스트를 통해 구조체를 정의하였다.

다른 풀이를 보니 adjacent matrix 방식의 그래프를 정의하여 풀기도 하는 모양이다.
문제에서 제시한 대로 한사람이 다른 사람을 여러 번 신고할 수 있지만,
그럼에도 신고 횟수는 한번으로 인식해야 하기 때문에 이런 풀이가 가능한 것으로 보인다.


### <b> 2. k진수에서 소수 개수 구하기 </b>

문제 해결에 사용된 전반적인 알고리즘은 브루트 포스이다.
기본적으로 문제에세 제시한 상황을 그대로 구현하였으며,
그 이상의 알고리즘 테크닉을 요구하지는 않는 것으로 보인다.

한가지 유의할 점은 해당 문제가 소수 판별 알고리즘을 포함한다는 것이다.
일반적으로 소수 판별 알고리즘을 구현하면 자기 자신보다 작은 모든 숫자에 대해 나우어 떨어지는 지를 확인해야 하는데,
이렇게 구현한 소수 판별 알고리즘의 경우 그 시간복잡도가 O(n)이지만, 
제곱근보다 큰 숫자에 대해서는 확인할 필요가 없다는 사실을 이용하면 O(sprt(n))까지 줄일 수 있다.
이 사실을 잘 활용하면 보다 빠르게 동작하는 알고리즘을 구현할 수 있다.


### <b> 3. 주차 요금 계산 </b>

부르트 포스를 사용하였고, 문제에서 제시하는 상황을 그대로 구현하였다.
내부적으로 보다 빠른 참조를 위해 딕셔너리를 적극적으로 이용하였고,
그 외의 트릭은 사용되지 않았다.


### <b> 4. 양궁대회 </b>

DFS를 사용한 완전 탐색 알고리즘을 활용하였다.
라이언이 n개의 화살을 쏘는 각각의 시나리오를 통해 상태 공간을 구성하면,
이 문제는 라이언이 어피치를 가장 높은 점수차로 이길 수 있는 상태를 찾는 문제로 바뀌게 되는데,
이런 문제는 DFS를 이용한 완전 탐색을 이용하면 쉽게 해결할 수 있다.
만약 n개의 화살을 모두 소진한 경우 라이언이 이길 수 있는 시나리오에서는 점수차를 계산하고,
이길 수 없는 시나리오에 대해서는 -1을 출력한다.

문제를 자세히 살펴보면 상태 공간이 분기하는 과정을 간략화 할 수 있다는 사실을 눈치챌 수 있다.
예를 들어 현재 상태(길이가 11인 배열)가 pivot까지 정의되었다고 가정할 때,
라이언은 다음과 같은 선택을 할 수 있다:

* 라이언은 pivot에 해당하는 점수를 얻기 위해 어피치가 pivot에 맞춘 화살 개수보다 1개를 더 맞춘다.
* 라이언은 pivot에 해당하는 점수를 포기하여 0개의 화살을 맞춘뒤 다른 점수를 노린다.

만약 남은 화살이 충분하기 않아 pivot에 해당하는 점수를 얻을 수 없는 경우에는 어쩔 수 없이
해당 점수를 포기해야 될 수도 있다.
또한 위의 두 경우에 대한 점수차가 같은 경우, 더 낮은 점수를 얼마나 더 많이 얻었는지를 분석하여,
더 적은 점수를 많이 맞춘 시나리오를 정답으로 간주한다.

이 알고리즘의 가장 큰 문제는 재귀 함수의 호출과정에서 반드시 상태의 복사가 일어나야 한다는 점이다
이 문제의 경우 상태가 분기하는 횟수가 11로 고정되어있어 탐색해야 하는 상태의 개수가 일정하므로,
이렇게 구현해도 상관 없지만,
어떤 경우에는 이 방식으로 알고리즘을 구현하면 메모리 제한에 걸릴 위험이 있어 보인다.


### <b> 4. 양과 늑대 </b>

노드의 개수가 17개로 고정되어 있으므로 단순하게 완전탐색 알고리즘을 적용하여 해결한다.
다만, 이 경우에는 탐색의 대상이 트리의 노드가 아니라 탐색한 트리의 노드들에 대한 집합이라는 점이다.
양과 늑대의 수는 탐색한 노드들에 대한 양과 늑대 개수의 합이랑 동일하므로,
탐색한 노드들에 대한 집합을 순회함으로써 최대 양의 개수를 탐색할 수 있다.

일반적으로 파이썬에서는 여러 개의 원소를 저장할 때 set 자료형을 이용한다.
하지만 bit-masking set을 이용한다면 보다 적은 메모리 공간만을 차지하면서 집합을 구현할 수 있다.
코드에서는 이를 이용하여 집합을 구현하였다.


### <b> 5. 파괴되지 않은 건물 </b>

특정한 좌표 공간에서 특정한 숫자를 더하는 행위는 imos 알고리즘을 통해 효율적으로 구현할 수 있다.
imos 알고리즘의 개요는 영역에 숫자를 더하는 방법을 누적합의 형태로 표현하는 것이다.

예를 들어 선분에서의 좌표 1부터 3까지 숫자 N을 더하는 과정을 imos 알고리즘을 통해 표현하면 다음과 같다.

* 먼저 적용하고자 하는 좌표 공간과 동일한 크기의 배열을 정의한다.
* 1 위치에 N을 저장한다.
* (3+1) 위치에 -N을 저장한다.
* 이후 누적합을 통해 각 좌표 공간에 더할 숫자를 계산할 수 있다.

평면에서의 imos 알고리즘은 선분에서의 imos 알고리즘을 확장하여 구현한다.
선분에서의 imos 알고리즘은 누적합을 계산하는 방향이 하나이지만, 
평면에서는 누적합을 계산하는 방향이 두 개이다.
예를 들어 평면에서의 좌표 (1, 1)부터 (3, 3)까지 숫자 N을 더하는 과정은 다음과 같이 표현된다.

* 먼저 적용하고자 하는 좌표 공간과 동일한 크기의 배열을 정의한다.
* (1, 1) 위치에 N을 저장한다.
* (1, 3+1) 위치에 -N을 저장한다.
* (3+1, 1) 위치에 -N을 저장한다.
* (3+1, 3+1) 위치에 N을 저장한다.
* 가로 방향으로 누적합을 계산한다.
* 세로 방향으로 누적합을 계산한다.

위의 방식으로 skill 배열을 imos의 형태로 변환한다. (코드에서는 diff 배열)
이렇게 변환된 배열의 누적합을 계산함으로써 최종적으로 각 좌표계에 더할 값을 구하고,
파괴되지 않은 건물의 개수를 센다.


### <b> 6. 사라지는 발판 </b>

