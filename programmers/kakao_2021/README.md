<h2><b><a href=https://programmers.co.kr/learn/challenges style="text-decoration:none;color:inherit">
2022 KAKAO BLIND RECRUITMENT
</a></b></h2>


### <b> 1. 신고 결과 받기 </b>

전형적인 브루트 포스 문제로 해석했고, 문제에서 제시한 상황을 그대로 구현하였다.
아이디를 참조하는 상황이 많이 발생하였으므로 속도를 위해 딕셔너리 자료형을 사용하였다.
C++이었으면 여러 데이터를 묶어 객체화 하기 위해 구조체를 정의하여 사용하였겠지만, 
파이썬에서는 리스트(동적배열)이 담을 수 있는 자료형이 고정되어있지 않으므로,
리스트를 통해 구조체를 정의하였다.

다른 풀이를 보니 adjacent matrix 방식의 그래프를 정의하여 풀기도 하는 모양이다.
문제에서 제시한 대로 한사람이 다른 사람을 여러 번 신고할 수 있지만,
그럼에도 신고 횟수는 한번으로 인식해야 하기 때문에 이런 풀이가 가능한 것으로 보인다.


### <b> 2. k진수에서 소수 개수 구하기 </b>

문제 해결에 사용된 전반적인 알고리즘은 브루트 포스이다.
기본적으로 문제에세 제시한 상황을 그대로 구현하였으며,
그 이상의 알고리즘 테크닉을 요구하지는 않는 것으로 보인다.

한가지 유의할 점은 해당 문제가 소수 판별 알고리즘을 포함한다는 것이다.
일반적으로 소수 판별 알고리즘을 구현하면 자기 자신보다 작은 모든 숫자에 대해 나우어 떨어지는 지를 확인해야 하는데,
이렇게 구현한 소수 판별 알고리즘의 경우 그 시간복잡도가 O(n)이지만, 
제곱근보다 큰 숫자에 대해서는 확인할 필요가 없다는 사실을 이용하면 O(sprt(n))까지 줄일 수 있다.
이 사실을 잘 활용하면 보다 빠르게 동작하는 알고리즘을 구현할 수 있다.


### <b> 3. 주차 요금 계산 </b>

부르트 포스를 사용하였고, 문제에서 제시하는 상황을 그대로 구현하였다.
내부적으로 보다 빠른 참조를 위해 딕셔너리를 적극적으로 이용하였고,
그 외의 트릭은 사용되지 않았다.


### <b> 4. 양궁대회 </b>

DFS를 사용한 완전 탐색 알고리즘을 활용하였다.
라이언이 n개의 화살을 쏘는 각각의 시나리오를 통해 상태 공간을 구성하면,
이 문제는 라이언이 어피치를 가장 높은 점수차로 이길 수 있는 상태를 찾는 문제로 바뀌게 되는데,
이런 문제는 DFS를 이용한 완전 탐색을 이용하면 쉽게 해결할 수 있다.
만약 n개의 화살을 모두 소진한 경우 라이언이 이길 수 있는 시나리오에서는 점수차를 계산하고,
이길 수 없는 시나리오에 대해서는 -1을 출력한다.

문제를 자세히 살펴보면 상태 공간이 분기하는 과정을 간략화 할 수 있다는 사실을 눈치챌 수 있다.
예를 들어 현재 상태(길이가 11인 배열)가 pivot까지 정의되었다고 가정할 때,
라이언은 다음과 같은 선택을 할 수 있다:

* 라이언은 pivot에 해당하는 점수를 얻기 위해 어피치가 pivot에 맞춘 화살 개수보다 1개를 더 맞춘다.
* 라이언은 pivot에 해당하는 점수를 포기하여 0개의 화살을 맞춘뒤 다른 점수를 노린다.

만약 남은 화살이 충분하기 않아 pivot에 해당하는 점수를 얻을 수 없는 경우에는 어쩔 수 없이
해당 점수를 포기해야 될 수도 있다.
또한 위의 두 경우에 대한 점수차가 같은 경우, 더 낮은 점수를 얼마나 더 많이 얻었는지를 분석하여,
더 적은 점수를 많이 맞춘 시나리오를 정답으로 간주한다.

이 알고리즘의 가장 큰 문제는 재귀 함수의 호출과정에서 반드시 상태의 복사가 일어나야 한다는 점이다
이 문제의 경우 상태가 분기하는 횟수가 11로 고정되어있어 탐색해야 하는 상태의 개수가 일정하므로,
이렇게 구현해도 상관 없지만,
어떤 경우에는 이 방식으로 알고리즘을 구현하면 메모리 제한에 걸릴 위험이 있어 보인다.


### <b> 4. 양과 늑대 - 미해결</b>

이진 트리 형태의 그래프에서,
특정한 종류의 노드들이 모여있는 클러스터들에 대한 탐색 순서를 결정하는 문제로 이해하였다.
첫인상으로는 priority queue를 활용한 BFS 알고리즘을 통해 이 문제를 해결할 수 있을 것으로 보인다.


### <b> 5. 파괴되지 않은 건물 - 미해결 </b>

굉장히 간단한 문제이지만, 건물의 개수가 최대 백만개로 너무 많아 브루트포스로 이 문제를 해결할 수는 없어 보인다.
대신 여러가지 알고리즘적 트릭을 적용하여 시간복잡도를 최소화해야 할 것으로 보인다.

(가정) skill 배열을 정렬하고 동적계획법을 적용하면 보다 빠르게 연산할 수 있을 것으로 보인다.
