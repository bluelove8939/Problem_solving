# 전자레인지 (Baekjoon Online Judge ID: 10162)
# 
# Url: https://www.acmicpc.net/problem/10162
# 
# 
# 알고리즘 분류: 그리디 알고리즘
#   
# Hint
# 1. 이 문제는 그리디 알고리즘을 이용하여 풀 수 있다.
# 
#
# 풀이
# - 그리디 알고리즘은 현재 최선의 선택만을 하여 정답을 도출해내는 알고리즘이다.
#   그리디 알고리즘은 완전탐색 알고리즘과는 다르다. 완전탐색 알고리즘들은 모든
#   경우의 수들을 다 탐색하지만 그리디 알고리즘은 현재 최선의 경우의 수만 탐색하기
#   때문이다. 따라서 그리디 알고리즘으로 구현한 코드들은 대부분의 경우 완전탐색 
#   알고리즘보다 빠르지만, 특정 문제에서는 적용할 수 없으므로 유의해야 한다.
# 
# - 이 문제는 12번 문제와 거의 동일한 문제로 동일한 방법으로 풀 수 있다.
#   12번 문제에서 했던 것을 참고하여 다음 과정을 스스로 해보도록 하자:
# 
#   1) 문제를 풀어본다
#   2) 알고리즘의 개요를 작성한다
#   3) 알고리즘의 정당성을 증명한다


# [1] 알고리즘의 개요
#   
#   1) 시간을 입력 받는다.
#   2) 가장 긴 시간에 해당 하는 버튼을 가능한 한 많이 누른다.
#   3) 남은 시간을 계산한다.
#   4) 모든 버튼에 대해 2) ~ 3)을 수행한다.
#   5) 남은 시간이 있는지 확인한다. 이때, 
#      5-1) 만약 남은 시간이 없다면 각 버튼을 누른 횟수를 출력한다
#      5-2) 만약 시간이 남았다면 세가지 버튼 조합으로 문제에서 주어진 시간을
#           만드는 것이 불가능하므로 -1을 출력한다


# [2] 알고리즘의 정당성 증명
# 
#   위의 알고리즘에서 중심이 되는 명제는 다음과 같다:
#   
#   가장 긴 시간이 걸리는 버튼을 가능한 많이 누르면 최소 횟수로 주어진 시간을 만들 수 있다.
# 
#   위의 명제가 거짓이라고 가정하자. 그러면 최소 조건을 달성한 경우 긴 시간이 걸리는 버튼을
#   더 적게 눌러야 한다. 이때 더 많은 시간이 걸리는 버튼은 상대적으로 더 적은 시간이 걸리는
#   버튼의 배수이므로, 많은 시간이 걸리는 버튼을 적게 누르면 적은 시간이 걸리는 버튼을 그만큼
#   더 많이 눌러야 한다. 따라서 앞서 한 가정은 최소 조건에 모순이고, 알고리즘은 정당하다.


# [+] 그리디 알고리즘을 사용할 수 없는 조건 
#
#   더 많은 시간이 걸리는 버튼이 더 적은 시간이 걸리는 버튼의 배수가 아닌 경우엔 위
#   알고리즘을 사용할 수 없다. 예를 들어 A버튼이 5분이 걸리고 B버튼이 4분이 걸리는
#   경우가 이에 해당한다. 


if __name__ == "__main__":
    # 1) 시간을 입력받는다
    T = int(input())
    buttons = [300, 60, 10]
    cnt = [0, 0, 0]

    # 4) 모든 버튼에 대해 2) ~ 3)을 수행한다.
    for idx, time in enumerate(buttons):
        # 2) 가장 긴 시간에 해당 하는 버튼을 가능한 한 많이 누른다.
        cnt[idx] += T // time

        # 3) 남은 시간을 계산한다.
        T %= time
    
    # 5) 남은 시간이 있는지 확인한다. 이때, 
    if T == 0:
        # 5-1) 만약 남은 시간이 없다면 각 버튼을 누른 횟수를 출력한다
        print(' '.join(list(map(str, cnt))))
    else:
        # 5-2) 만약 시간이 남았다면 -1을 출력한다
        print(-1)
