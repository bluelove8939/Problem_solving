# 거스름돈 (Baekjoon Online Judge ID: 5585)
# 
# Url: https://www.acmicpc.net/problem/5585
# 
# 
# 알고리즘 분류: 그리디 알고리즘
#   
# Hint
# 1. 이 문제는 그리디 알고리즘을 이용하여 풀 수 있다.
# 
#
# 풀이
# - 그리디 알고리즘은 현재 최선의 선택만을 하여 정답을 도출해내는 알고리즘이다.
#   그리디 알고리즘은 완전탐색 알고리즘과는 다르다. 완전탐색 알고리즘들은 모든
#   경우의 수들을 다 탐색하지만 그리디 알고리즘은 현재 최선의 경우의 수만 탐색하기
#   때문이다. 따라서 그리디 알고리즘으로 구현한 코드들은 대부분의 경우 완전탐색 
#   알고리즘보다 빠르지만, 특정 문제에서는 적용할 수 없으므로 유의해야 한다.
# 
# - 이 문제는 그리디 알고리즘을 이용하여 풀 수 있는 대표적인 형태의 문제이다. 그리디
#   알고리즘의 코드 구조는 매우 단순하므로, 알고리즘의 정당성을 판별하는 부분을 좀 더
#   주의깊게 보는 것이 좋다. 
# 
# - 이 문제는 거스름돈을 일정한 금액의 동전으로 거슬러줄 때, 동전의 최소 개수를
#   구하는 문제이다. 직관적으로 봤을 때, 동전의 개수를 최소화하기 위해서는 더 높은
#   금액의 동전을 사용할 수 있는 한 많이 사용하는 것이 좋을 것으fh 보인다. (아직
#   증명한 것은 아니다)
# 
#   따라서 알고리즘의 개요는 직관적으로 다음과 같이 정리된다:
# 
#   1) 먼저 거스름돈의 총 액을 계산한다.
#   2) 계산한 거스름돈에서 최대 금액의 동전을 얼마나 줄 수 있는지를 계산한다.
#   3) 남은 거스름돈에서 그 다음으로 큰 금액의 동전을 최대 얼마나 줄 수 있는지를
#      계산한다.
#   4) 남은 거스름돈이 없어질 때까지 2) ~ 3)을 반복한다. 
# 
#   위의 알고리즘 개요를 통해 입력이 142엔일때 동전의 최소 개수를 구해보자:
# 
#   1) 거스름돈의 총액은 868엔(= 1000 - 142엔)이다.  
#   2) 현재 최대 금액의 동전은 500엔이며, 500엔짜리 동전은 최대 1개 줄 수 있고 남은
#      거스름돈은 368엔이 된다.
#   3) 그 다음으로 큰 금액의 동전은 100엔이다. 남은 거스름돈이 368엔이므로 100엔짜리
#      동전은 최대 3개 줄 수 있고, 남은 거스름돈은 68엔이다.
#   4) 그 다음으로 큰 금액의 동전은 50엔이다. 남은 거스름돈이 68엔 이므로 50엔짜리
#      동전은 최대 1개 줄 수 있고, 남은 거스름돈은 18엔이다.
#   5) 위의 과정을 거스름돈이 남지 않을 때 까지 반복한다. 그러면 10엔짜리 동전은 1개,
#      5엔짜리 동전은 1개, 1엔짜리 동전은 3개 줄 수 있다.
# 
#   위의 알고리즘은 직관적으로 봤을 때는 그럴듯해 보인다. 그렇지만 실제로도 그럴까?
#   이를 증명하기 위해서는 알고리즘의 정당성을 판별하는 과정이 필요하다. 
# 
# - 위 알고리즘은 귀류법을 통해 증명될 수 있다. 귀류법의 정의는 아래 링크를 참조한다.
#   귀류법: https://namu.wiki/w/%EA%B7%80%EB%A5%98%EB%B2%95
# 
#   위 알고리즘의 주 논리는 다음과 같다:
#   
#   먼저 높은 금액의 동전을 선택할 수 있는 한 최대한 선택하고 그 후 남은 동전들을 선택하면
#   가장 최소 개수의 동전으로 거슬러줄 수 있다.
# 
#   이를 귀류법으로 증명하기 위해서는 먼저 위 명제가 거짓이라고 가정해야 한다. 만약 동전의 개수가
#   최소인 상태에서 높은 금액 동전의 개수가 최대 개수가 아니라고 가정해보자. 이때 문제에서
#   주어진 동전들의 액수를 잘 살펴보면 더 큰 금액의 동전은 그보다 작은 금액의 동전의 배수이므로,
#   높은 금액의 동전을 더 적게 사용할 수록 낮은 금액의 동전을 무조건 더 많이 사용해야만 한다.
#   이는 전체 동전의 개수가 최소라는 원래의 가정에 모순이므로 따라서 위의 알고리즘은 정당하다.
# 
#   그렇다면 만약 각 동전의 금액이 500엔, 400엔, 100엔, 1엔이라면 어떨까? 이 경우는 앞서 소개한 그리디
#   알고리즘으로 풀 수 없다. 왜냐하면 400엔보다 큰 금액의 동전인 500엔이 400엔의 배수가 아니기 때문이다.
#   이런 경우 500엔짜리 동전을 더 적게 사용하면서 최소 개수의 조건을 달성하는 경우의 수가 있을 수 있다.
#   예를 들어 거스름돈이 800엔이라고 가정해보자. 위의 알고리즘을 이용하면 500엔짜리 1개, 100엔짜리 3개를
#   이용하여 거슬러주는 것이 제일 좋다. 그런데 실제로는 400엔짜리 동전 2개만으로 거슬러주는하는 것이
#   최선의 선택이다.
#   
#   이처럼 같은 문제여도 문제의 조건 등에 따라 단순히 그리디 알고리즘을 적용해서는 풀 수 없는 경우가
#   종종 있다. 따라서 그리디 알고리즘을 사용하기 위해서는 이 문제가 그리디 알고리즘을 사용할 수 있는지를
#   잘 판별해야 하며, 만약 사용할 수 없는 경우 동적계획법이나 혹은 다른 완전탐색 알고리즘을 활용하는
#   코드를 고민해봐야 한다.
#   
#   + 추가) 그렇다면 앞서 말한 경우의 문제는 어떻게 풀 수 있을까? 어떤 알고리즘을 사용해야 할까?
#     정답) 동적계획법 혹은 DFS를 이용한 완전탐색 알고리즘
# 
# - 앞서 말했듯, 모든 문제를 그리디 알고리즘으로 풀 수 있는 것은 아니다. 그리디 알고리즘을
#   이용하기 위해서는 현재 선택한 최선의 답이 미래에도 최선의 답이어야 한다. 이 문제에서 현재
#   최대 금액의 동전을 가능한 많이 선택하는 것은 미래에도 최선의 선택이라는 것이 보장되므로
#   그리디 알고리즘을 사용할 수 있다. 
# 
# - 앞서 확인했듯, 그리디 알고리즘은 많은 경우 재귀적으로 표현된다. 따라서 재귀함수를 이용하면
#   위와 같은 알고리즘을 쉽게 구현할 수 있다. 다만 경우에 따라서는 간단하게 반복문을 활용할 수도
#   있으니 참고할 것. 아래 코드에서는 단일 반복문을 이용하여 재귀 시퀀스를 구현했으나, 코드가
#   크게 더럽지 않다. (보통 재귀 시퀀스의 분기가 하나이면 반복문을 활용하는게 좋다. 분기가 두 개
#   이상이거나 그 개수가 변하는 경우는 재귀 함수를 작성한다.)  


if __name__ == "__main__":
    # 1. 거스름돈의 총 액을 계산한다
    change = 1000 - int(input())
    coins = [500, 100, 50, 10, 5, 1]
    cnt = 0

    # 4. 거스름돈이 남지 않을 때까지 2) ~ 3)을 반복한다.
    # 
    # - 동전의 최소 단위가 1엔이므로 모든 동전의 개수를 정의하면 남은 거스름돈은 없다  
    for num in coins:
        # 2. 더 높은 금액의 동전을 가능한 최대한 많이 선택한다
        cnt += change // num

        # 3. 남은 거스름돈을 계산한다
        change %= num
    
    print(cnt)